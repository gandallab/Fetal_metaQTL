#! /usr/bin/env Rscript

# Edited based on Leafviz and RW's code

library(data.table)
library(argparser)
library(stringr)
library(dplyr)
library(magrittr)

p <- arg_parser("Annotate Leafcutter detected introns")
p <- add_argument(p, "--annot", help="annotation code generated by leafviz")
p <- add_argument(p, "--counts", help="perind numers file generated by leafcutter")
p <- add_argument(p, "--outdir", help="")

args <- parse_args(p)

counts_file <- args$counts
annotation_code <- args$annot

# Leafviz annotation codes
exon_file <- paste0(annotation_code, "_all_exons.txt.gz")
all_introns <- paste0(annotation_code, "_all_introns.bed.gz" )
threeprime_file <- paste0(annotation_code, "_threeprime.bed.gz")
fiveprime_file <- paste0(annotation_code, "_fiveprime.bed.gz")

counts <- fread(counts_file, data.table = F)

################## Preparing ##################
all.introns <- as.data.frame(counts$V1)
colnames(all.introns) <- "intron"

all.introns <- as.data.frame(str_split_fixed(all.introns$intron, ":", 4), stringsAsFactors = FALSE )
names(all.introns) <- c("chr","start","end","clusterID")

all.introns$start <- as.numeric(all.introns$start)
all.introns$end <- as.numeric(all.introns$end)

# All 5' and 3' SJ of detected introns
all.junctions <- all.introns %>% select(chr, start, end, clusterID)

# all.introns_intersect: match detected introns to annotated introns, by CHR, START, END 
# some are matched, some are not
# some are mapped to multiple entries, e.g. same intron in multiple genes or transcripts
intron_db <- fread(file=paste0(annotation_code, "_all_introns.bed.gz"), data.table = F)
colnames(intron_db)[1:4] <- c("chr","start","end","gene")
all.introns_intersect <- all.junctions %>%
  left_join(intron_db, by=c("chr","start","end"))

# threeprime_intersect: match detected introns' 3' SJ to annotated 3' SJ
threeprime_db <- fread(file=paste0(annotation_code, "_threeprime.bed.gz"), data.table = F)
colnames(threeprime_db)[1:7] <- c("chr","start","end","gene","gene_id","strand","transcript")
threeprime_intersect <- all.junctions %>%
  select(chr, clusterID, start=end) %>%
  left_join(threeprime_db, by=c("chr","start"))

# fiveprime_intersect: match detected introns' 5' SJ to annotated 5' SJ
fiveprime_db <- fread(file=paste0(annotation_code, "_fiveprime.bed.gz"), data.table = F)
colnames(fiveprime_db)[1:7] <- c("chr","start","end","gene","gene_id","strand","transcript")
fiveprime_intersect <- all.junctions %>%
  select(chr, clusterID, start) %>%
  left_join(fiveprime_db, by=c("chr","start"))

################## Annotating introns ##################
verdict.list <- list()
coord.list <- list()
gene.list <- list()
ensemblID.list <- list()
transcripts.list <- list()
constitutive.list <- list()
classification.list <- list()

clusters <- unique(all.introns$clusterID)

# Counter. See below
counter <- 0

for( clu in clusters ){
  if (length(verdict.list) %% 1000 == 0) {
      cat( "Clusters processed: ", length(verdict.list), "\n" )
  }
  # for each intron in the cluster, check for coverage of both
  # output a vector of string descriptions
  cluster <- all.introns %>% filter( clusterID == clu )
  # cluster$chr <- paste0("chr", cluster$chr) 

  # first subset the intersected files to speed up later query
  fprimeClu <- fiveprime_intersect %>% filter( clusterID == clu )
  tprimeClu <- threeprime_intersect %>% filter( clusterID == clu )
  bothSSClu <- all.introns_intersect %>% filter( clusterID == clu )

  # for each intron in the cluster:
  # create vector of overlapping splice sites, indexed by the row of the intersect
  # five prime splice sites
  fprime <- cluster %>% left_join(fprimeClu, by=c("chr","start"))

  # three prime splice sites
  # tprimeClu has only start and end (start+1) coordinates for each intron's 3' SJ
  # left_join with cluster to get original coordiantes of intron
  # there could be multiple intron collapsed to one because they have the same 3' SJ
  tprime <- cluster %>% left_join(tprimeClu, by=c("chr"="chr","end"="start"))

  # both splice sites
  bothSS <- cluster %>% left_join(bothSSClu, by=c("chr","start","end"))

  # find gene and ensemblID of the most represented gene among all the splice sites - lazy
  cluster_gene <- names(sort(table(c(tprime$gene,fprime$gene)), decreasing = TRUE ))[1]

  # if no cluster gene found then leave as "."
  if( is.null(cluster_gene) ){
    cluster_gene <- "."
  }

  gene_strand <- NA
  if( cluster_gene != "." ){
    # get strand the same way - would prefer to use the strand of the junction
    strands <- c(tprime$strand, fprime$strand)
    # hope that all junctions align to the same gene on the same strand
    gene_strand <- unique( strands[ strands != "." & !is.na(strands) ])
    if( all(is.na(gene_strand)) | length(gene_strand) != 1 ){
      gene_strand <- NA
    }
  }

  # do the same for EnsemblID
  # cluster_ensemblIDs <- names(sort(table( c(tprime$gene_id,fprime$gene_id)), decreasing = TRUE ))
  # cluster_ensemblID <- cluster_ensemblIDs[ cluster_ensemblIDs != "." ][1]
  # if( length( cluster_ensemblID ) == 0 ){
  #   cluster_ensemblID == "."
  # }

  # Attempt 1: Original code has problem when ensemblID is NULL; just do the same as cluster gene
  # cluster_ensemblID <- names(sort(table( c(tprime$gene_id,fprime$gene_id)), decreasing = TRUE ))[1]
  # if( is.null(cluster_ensemblID) ){
  #   cluster_ensemblID <- "."
  # }
  
  # Attempt 2: above code has problem when two or more genes have the same number of representation; will select by alphabet; cluster_gene and cluster_ensemblID may not match!
  if ( cluster_gene != "." ) {
    if ( length(sort(table(c(tprime$gene,fprime$gene)), decreasing = TRUE)) >=2 ) {
      if ( sort(table(c(tprime$gene,fprime$gene)), decreasing = TRUE)[1] == sort(table(c(tprime$gene,fprime$gene)), decreasing = TRUE)[2] ) {
        cat("Equal representation. Selected", cluster_gene, "for", clu, "\n")
        counter <- counter + 1
      }
    }
    # this gene can be from either tprime or fprime
    # note some genes (very few, an example is C2orf27A)have more than one ensemblID
    # then the code will match intron cluster to the correct ensemblID it matches
    cluster_ensemblID <- unique(unlist(c(
      fprime %>% filter(gene == cluster_gene) %>% select(gene_id), 
      tprime %>% filter(gene == cluster_gene) %>% select(gene_id))))
  } else {
    cluster_ensemblID <- "."
  }

  verdict <- c()
  coord <- c()
  gene <- c()
  ensemblID <- c()
  transcripts <- list()

  # Get annotation for each intron in the cluster
  # All introns in the cluster will be mapped to the most represented gene/ensemblID of this cluster
  # verdict, transcripts and coord are specific to this intron
  for( intron in 1:nrow(cluster) ){
    coord[intron] <- paste(cluster[intron,]$chr,cluster[intron,]$start, cluster[intron,]$end )

    gene[intron] <- cluster_gene
    ensemblID[intron] <- cluster_ensemblID

    fprime_intron <- cluster[intron,] %>% left_join(fprime, by=c("chr","start"))
    tprime_intron <- cluster[intron,] %>% left_join(tprime, by=c("chr","end"))
    bothSS_intron <- cluster[intron,] %>% left_join(bothSSClu, by=c("chr","start","end"))

    # for each intron create vector of all transcripts that contain both splice sites
    # if one df has non-NA transcripts, the other all NA, will give ''
    # if both df have all NA transcripts, will give NA
    # in summarise_annot.R, '' is converted to '.'
    # so in the final output there are '.' and NA
    transcripts[[intron]] <- intersect( tprime_intron$transcript,fprime_intron$transcript )

    verdict[intron] <- "error"
    # either TRUE or FALSE
    unknown_3p <- all( is.na(tprime_intron$gene) )
    unknown_5p <- all( is.na(fprime_intron$gene) )

    if (is.na(gene_strand)) {
      verdict[intron] <- "unknown_strand"
    } else {
      if( all( is.na(tprime_intron$gene )) & all( is.na(fprime_intron$gene ) ) ){
        verdict[intron] <- "cryptic_unanchored"
      }
      if( (all( is.na(tprime_intron$gene )) & all( !is.na(fprime_intron$gene ) ) & all(gene_strand == "+") ) |
        ( all( is.na(fprime_intron$gene )) & all( !is.na(tprime_intron$gene ) ) & all(gene_strand == "-") )
      ){ verdict[intron] <- "cryptic_threeprime"
      }
      if(
        ( all( !is.na(tprime_intron$gene )) & all( is.na(fprime_intron$gene ) ) & all(gene_strand == "+") ) |
        ( all( !is.na(fprime_intron$gene )) & all( is.na(tprime_intron$gene ) ) & all(gene_strand == "-") )
      ){ verdict[intron] <- "cryptic_fiveprime"
      }
      if( is.na(gene_strand) & ( all( !is.na(tprime_intron$gene )) | all( !is.na(fprime_intron$gene ) ) ) ){
        verdict[intron] <- "cryptic"
      }
      if( # if both splice sites are annotated
        all( !is.na(tprime_intron$gene ) ) & all( !is.na(fprime_intron$gene ) )
      ){
        # test if the splice sites are paired in a known intron
        if( all( !is.na(bothSS_intron$gene )) ){
          verdict[intron] <- "annotated"
        }else{ # both are annotated but never in the same junction
          verdict[intron] <- "novel annotated pair"
        }
      }
    }
    verdict.list[[clu]] <- verdict
    coord.list[[clu]] <- coord
    gene.list[[clu]] <- gene
    ensemblID.list[[clu]] <- ensemblID

    # once all the transcripts for all the introns are found, go back and work out how many constitutive each junction is. Does the junction appear in every transcript?

    if( intron == nrow(cluster)){ # only on final intron
      all_transcripts <- unique( unlist( transcripts ) )
      # remove "." - non-existent transcripts
      all_transcripts <- all_transcripts[ all_transcripts != "." ]

      constitutive <- lapply( transcripts, FUN = function(x) {
        # for each intron how many transcripts is it seen in?
        x <- x[ x != "." ]
        length(x) / length( all_transcripts)

        })

      constitutive.list[[clu]] <- constitutive

      # collapse all.introns transcripts for each intron into a single string
      transcripts.list[[clu]] <- lapply(transcripts, FUN = function(x) paste( x, collapse = "+" ) )

    }

  }

  # predicting the event type from the shape of the junctions
  #print(clu)

  if( nrow(cluster) != 3){
    classification.list[[clu]] <- "."
    next
  }else{
    classification.list[[clu]] <- "."

    tab <- select(cluster, start, end)

    # the junctions are sorted by start and end coordinates

    # check for the presence of a junction that spans the entire length of the cluster
    if( !any(  which( tab$start == min(tab$start) ) %in% which( tab$end == max(tab$end) )  ) ){
      classification.list[[clu]] <- "."
      next
    }

    # therefore for a cassette exon arrangement the longest junction always comes second
    if( which( tab$start ==  min(tab$start) & tab$end == max(tab$end ) ) != 2 ){
     classification.list[[clu]] <- "."
     next
    }

    # now we know that junction 2 is the parent, junction 1 is the left most child and junction 3 is the right most
    # check that the end of junction 1 comes before the start of junction 3

    if( tab[1,"end"] > tab[3,"start"] ){
      classification.list[[clu]] <- "."
      next
    }

    # double check the starts and ends
    if( tab[1, "start"] != tab[2,"start"] | tab[3,"end"] != tab[2,"end"] ){
      classification.list[[clu]] <- "."
      next
    }


    # work out annotation status
    if( all( verdict.list[[clu]] == "annotated") ){
      classification.list[[clu]] <- paste0( classification.list[[clu]], " - annotated")
    }

    if( verdict.list[[clu]][2] == "annotated" & verdict.list[[clu]][1] != "annotated" & verdict.list[[clu]][3] != "annotated"  ){
      classification.list[[clu]] <- paste0( classification.list[[clu]], " - cryptic")
    }

    if( verdict.list[[clu]][2] == "novel annotated pair" & verdict.list[[clu]][1] == "annotated" & verdict.list[[clu]][3] == "annotated"  ){
      classification.list[[clu]] <- paste0( classification.list[[clu]], " - skiptic")
    }

  }

}

cat( counter, "clusters got genes with equal representation. Selected one among the top genes.\n" )

save(all.introns,
     verdict.list,
     coord.list,
     gene.list,
     ensemblID.list,
     transcripts.list,
     constitutive.list,
     classification.list,
     file = paste0(args$outdir, "leafviz.RData"))
